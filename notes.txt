----THOUGHTS
I'm going to end up having a pick_route function that 
returns a route. build_route will no longer have logic to
make the NN route/order, but will still build Stops. I will
probs call it build_stops_for_route instead of build_route

Alright, here's my strategy for the end:
ESTIMATE: 4:04-5:00
	0.1 rewrite nn_total_dist to also return route itself
	1. write+call order_route that uses build_'s NN logic)
		just using above but I'll still refer to build_ later
	2. write+call add_throughout, not using helpers
-COMMIT- EST. 4:40-ACTUAL: 5:20
	3. write+call add_to_end, not using helpers
	4. extend both add_'s to call same_dest, deliver_with
GIT PUSH + browse
ESTIMATE: 5:50-6:40
	5. write+call non-iterative swap_segs for n=3 segs
-COMMIT- EST. 6:20
	6. extend swap_ by putting in a loop for n=3 to n=8
		and also putting each n in a loop to go again if 
		it got shorter
GIT PUSH + snack
ESTIMATE 6:50-7:40
	7. rename pick_load to pick_route, rename build_route to build_stops_for_route, and either remove or use Locations arg to build_
	8. build __main__ to 'loop'--to send whichever truck
		finished first (of all trucks-with-drivers) again
-COMMIT- EST. 7:15
	9. clean/tidy up, make final todos,, make sure docstrings are filled in, and test out docstrings.
	10. final SMALL todos collected from step 9
GIT PUSH + walk
ESTIMATE 7:50-8:30
	11. add some tests. ALSO improve the readme.md
GIT PUSH + GO HOME
ESTIMATE 9:30-10:30 AT HOME, plus tomorrow morning
	12...back to the write-up...


I have a set to meet some constraints--how do I optimally pick the rest?
I'm thinking something like this:

construct an ordering to the packages so far, built off NN
make a list of locations having (non-truck-restricted) pkgs still remaining

while not yet long enough: add throughout (helper)
	at the beginning, is the NN the closest among the 'remaining'?
		if not, continue
		if it is, how close is it?
			if it's not more than twice as long for A-C-B than A-B, insert
			else continue

while still not yet long enough: add to end (helper)
	find NN to end, add it, and then we're done

it'd be nice to save the order for build_route;it'd make code more readable
ESPECIALLY if I made pick_load do segment-swapping too

  If I need to/could describe 'destinations corrections' in my write-up...
"Destination corrections are received from the user of a program. This is necessary because currently neither corrected destinations nor the time by which a corrected destination will be known is part of the ‘package’ csv input file. Functionality in the cli module gathers all known destination-corrections and updates the relevant packages."

----TODO BEFORE FINISHING:
- Write and run more tests
- Test out all the docstrings! Specifically, find out if I need to insert spaces at the beginning of very multi-line comment/docstring after the first line.

----GOOD PLANNING - notes from How to Design Programs / HtDP
TIPS
	1. Keep a wish list around and as long as it's not empty, work from it
	2. One function per task
	3. Focus on the why, not how, especially in the purpose statement.
Do not pay attention to how until you need to. (Especially for recursion.)
	4. For some list processing you may want to ensure
a list is non-empty before working with it.

WISH LIST
	1. meaningful name for the function
	2. signature (consume/produce)
	3. purpose statement

SHORT DESIGN RECIPE
	1. analyze problem
	2. write what kind of data is consumed and produced, what is computed, and write a stub/signature
	3. work through examples
	4. outline the function
	5. flesh out the function
	6. test

FUNCTION DESIGN RECIPE
	1. tentative function-name and multi-line comment
	2. sentence(s) on what it's supposed to, especially in terms of data
	3. data definitions/context--what kind of data, and what it represents
	4. parameters and return statement
	5. one-line purpose
	6. improve function name
	7. delete sentence(s) from step 2
	6. generate examples as given:/expect:
	7. convert simpler examples to test(s)
	8. develop the function
	9. pass those test(s)
	10. convert more examples into tests
	11. develop the function
	12. pass those tests
	13. move the tests into a testing file and rerun them there
	14. clean up the function
---------------------------------------------------------------------------
----assoc with git commit 3a7319a
----meta note: to get the git commit, I first commit, then check the commit
----hash, then paste it in this file, then git commit --amend --no-edit
# TESTING IMPORTS
# First, test main.py itself, with this
hash_ex = Hash()
print(str(hash_ex))
# Then test imports in other modules. the below strategy is adequate:
# put the following in main.py
from tests.algorithms_tests import *
from tests.hash_tests import *
truck_test()
cli.cli_test()
algorithms_tests_test()
general_tests_test()
hash_test()
# put in truck.py
def truck_test():
    function_for_testing_imports('1')
# put in cli.py
def cli_test():
    function_for_testing_imports('2')
# put in tests/algorithms_tests
def algorithms_tests_test():
    function_for_testing_imports('3')
# put in tests/general_tests
def general_tests_test():
    function_for_testing_imports('4')
# put in package
def function_for_testing_imports(param):
    print(f"well hello there{param}")
# put in hash
def hash_test():
    hash_ex = Hash()
    print(f"called from hash_tests, here's a hash: {str(hash_ex)}")
----
---- assoc with git commit ?
