----NEXT?
9:58 I forgot where I left off yesterday: I know I fixed a bug whereby for_here and goes_with could overlap, or something.

I know I was trying to figure out what is ACTUALLY going on in my program because route_builder isn't transparent enough. I added some good print statements, but was thinking about some tests. I know that both add_ methods don't seem to work, and not sure about optimize_, which I know has two bugs: it isn't resetting distances and it moves start and end when it shouldn't (two bugs). 

The next thing I'm going to do is get main to hopefully 'work' in that trucks keep coming until delivery is done, and total distance is reported and all packages are on time. 
	If that doesn't happen, I'll find out why.
	And once it does, I'll fix my route stuff.

10:07 Oh yeah-candidate stops may not be populating, I'll check that now. Also: only 17 pkgs and 82.9 dist after 2 loads? Bad.

10:17 new problem: despite turning off optimize_, I saw a route not starting with stop 1. Also, looks like I have duplicate stops again. 
Finally, a time of 0 though I don't know why/where it came from.

10:43 add_nearby_neighbors is putting things before hub at start, and it's also re-adding a stop already in route (#22)
Ah: changed insert to index + 1, and called remove candidate stops for all stops currently in route--in packages_on_way.

10:59 Aw shit, bad bug. Goes_with packages are currently being added to the current stop's package, and of course that's wrong. How on earth am I supposed to add stops at every single point that I call deliver_with? 
I may need to do ANOTHER rewrite :/

11:14 I decided to do a rewrite, because of the big deliver thing, and I'll just do deliver with first. 

11:25 brief break, thinking, no don't do deliver-with first but DO remove from consideration any deliver-with packages at all afte rthe initial truck+deadline picks .. and only when no more of those exist then get as many deliver-withs as possible..??



----from How to Design Programs / HtDP
TOP TIPS
	1. Keep a wish list around and as long as it's not empty, work from it
	2. One function per task
	3. Focus on the why, not how, especially in the purpose statement. Do not pay attention to how until you need to. (Especially for recursion.)
	4. For some list processing you may want to ensure
a list is non-empty before working with it.

WISH LIST
	1. meaningful name for the function
	2. signature (consume/produce)
	3. purpose statement

SHORT DESIGN RECIPE
	1. analyze problem
	2. write what kind of data is consumed and produced, what is computed, and write a stub/signature
	3. work through examples
	4. outline the function
	5. flesh out the function
	6. test

FUNCTION DESIGN RECIPE
	1. tentative function-name and multi-line comment
	2. sentence(s) on what it's supposed to, especially in terms of data
	3. data definitions/context--what kind of data, and what it represents
	4. parameters and return statement
	5. one-line purpose
	6. improve function name
	7. delete sentence(s) from step 2
	6. generate examples as given:/expect:
	7. convert simpler examples to test(s)
	8. develop the function
	9. pass those test(s)
	10. convert more examples into tests
	11. develop the function
	12. pass those tests
	13. move the tests into a testing file and rerun them there
	14. clean up the function
-----------------------------------------------------------------
For later..
  If I need to/could describe 'destinations corrections' in my write-up...
"Destination corrections are received from the user of a program. This is necessary because currently neither corrected destinations nor the time by which a corrected destination will be known is part of the ‘package’ csv input file. Functionality in the cli module gathers all known destination-corrections and updates the relevant packages."

----TODO BEFORE FINISHING:
- Write and run more tests
- Improve readme
- Test out all the docstrings! Specifically, find out if I need to insert spaces at the beginning of very multi-line comment/docstring after the first line.
-----------------------------------------------------------------
----assoc with git commit 3a7319a
----meta note: to get the git commit, I first commit, then check the commit
----hash, then paste it in this file, then git commit --amend --no-edit
# TESTING IMPORTS
# First, test main.py itself, with this
hash_ex = Hash()
print(str(hash_ex))
# Then test imports in other modules. the below strategy is adequate:
# put the following in main.py
from tests.algorithms_tests import *
from tests.hash_tests import *
truck_test()
cli.cli_test()
algorithms_tests_test()
general_tests_test()
hash_test()
# put in truck.py
def truck_test():
    function_for_testing_imports('1')
# put in cli.py
def cli_test():
    function_for_testing_imports('2')
# put in tests/algorithms_tests
def algorithms_tests_test():
    function_for_testing_imports('3')
# put in tests/general_tests
def general_tests_test():
    function_for_testing_imports('4')
# put in package
def function_for_testing_imports(param):
    print(f"well hello there{param}")
# put in hash
def hash_test():
    hash_ex = Hash()
    print(f"called from hash_tests, here's a hash: {str(hash_ex)}")
