NEW Problems + Resolutions
(1) I have nothing guaranteeing packages delivered on time. 
But I figure I could do so. My current thought is to...
 - track how many cumulative miles each deadline-pkg can be
 - pass to improve_route and cut out 'improved's that
 - assert or try/except improve_route's min, just in case some
 deadline makes a route actually impossible (so min would be on [])
TODO: I'll make a new Block 6 for this with 1-2 sub-blocks
(2) Distance is unreasonable right now. It's extremely unlikely to be much less than 80 or 90, and maybe even 100. Partly (only partly) b/c I was testing both truck + deadline constraints together
It's actually so much worse than I thought-72 miles for first 16. It's also somehow 155 miles for 29 packages--BAD.
TODO: Come back to this later after blocks 4-6. New Block 7?

LEFT OFF: finishing dest-correction code.
For some reason just as I was about to leave it stopped working in that 39/40 are delivered, not 40. Was so close!
About ready to move on to Block 4!

AFTER coding blocks:
 - WRITING Block N+1 < 
 	- SB 6.1 < ? ?7:15@RoCo 1.5h
 	Write as fast as possible
 	- SB 6.2 < ? ?9:00@RoCo 0.75h
 	Clean up writing & Submit writing+code
 - PRESENTATION N+2 < 
 	- SB 7.1 < ? ?10:00@RoCo 1h
 	Add requirements + my features to readme
 	- SB 7.2 < ? ?11:15@RoCo 0.5h 
 	Comb code for professionalism, test docstrings + pin repo
 - UNIT TESTS N+3 < 
 	- SB 8.1 < ? ?12:00@RoCo 1.75h
 	Add some tests and do any last to-dos.
Initial estimate: 15h
Now on track for: 17h
Actual time spent: ?h

DONE:
# BLOCK 1 (3 TEST blocks):
# X  TEST (1/2): works up to now--first/final, try/except, trk-deliver
# add urgent deadlines to temp list
# X  TEST (2/2 for Subblock 1): truck load gets urgent pkgs

# check if full, if so, randomly eject right # to be full
# iff truck initial leave time >= 9:00am, also add other deadlines
# check if full, if so, randomly eject right # to be full
# add deliver-withs not in there yet to temp list
# X  TEST: d-w added (alter data to make it happen if need be)

# check if size ok and if not eject d-w in reverse size-order until ok
# _  TEST: alter data so size exceeded and know+check expected result

# BLOCK 2 (2 TEST blocks, retroactively):
# add truck constraints to temp list
# check if full, if so, randomly eject right # to be full
# add deliver-withs not in there yet to temp list
# X  TEST: (1) truck (alter in main) (2) d-ws added (alter in load)

# check if size ok and if not, eject d-w in reverse size-order until ok
# if room left smaller than avail - sum(d-w's), remove d-ws from ready,
# else add d-ws until no more groups can fit
# X  TEST: set up many d-ws, then test groups added until can't fit

# BLOCK 3 (3 TEST blocks, 2 retroactively added):
# 3.1 create route order from those packages' stops: just use NN,
# X  TEST: route note messed up/order/distances are reasonable

# 3.2 make sure destination-correction code works
# X  TEST: user can supply dest. corr. code, plus one manually added

# 3.3 plus (NEWLY ADDED) make sure main..
# X  TEST: main loops until all packages are delivered
        
----from How to Design Programs / HtDP
TOP TIPS
	1. Keep a wish list around and as long as it's not empty, work from it
	2. One function per task
	3. Focus on the why, not how, especially in the purpose statement. Do not pay attention to how until you need to. (Especially for recursion.)
	4. For some list processing you may want to ensure
a list is non-empty before working with it.

WISH LIST
	1. meaningful name for the function
	2. signature (consume/produce)
	3. purpose statement

SHORT DESIGN RECIPE
	1. analyze problem
	2. write what kind of data is consumed and produced, what is computed, and write a stub/signature
	3. work through examples
	4. outline the function
	5. flesh out the function
	6. test

FUNCTION DESIGN RECIPE
	1. tentative function-name and multi-line comment
	2. sentence(s) on what it's supposed to, especially in terms of data
	3. data definitions/context--what kind of data, and what it represents
	4. parameters and return statement
	5. one-line purpose
	6. improve function name
	7. delete sentence(s) from step 2
	6. generate examples as given:/expect:
	7. convert simpler examples to test(s)
	8. develop the function
	9. pass those test(s)
	10. convert more examples into tests
	11. develop the function
	12. pass those tests
	13. move the tests into a testing file and rerun them there
	14. clean up the function
-----------------------------------------------------------------
For later..
  If I need to/could describe 'destinations corrections' in my write-up...
"Destination corrections are received from the user of a program. This is necessary because currently neither corrected destinations nor the time by which a corrected destination will be known is part of the ‘package’ csv input file. Functionality in the cli module gathers all known destination-corrections and updates the relevant packages."

----TODO BEFORE FINISHING:
- Write and run more tests
- Improve readme
- Test out all the docstrings! Specifically, find out if I need to insert spaces at the beginning of very multi-line comment/docstring after the first line.
-----------------------------------------------------------------
----assoc with git commit 3a7319a
----meta note: to get the git commit, I first commit, then check the commit
----hash, then paste it in this file, then git commit --amend --no-edit
# TESTING IMPORTS
# First, test main.py itself, with this
hash_ex = Hash()
print(str(hash_ex))
# Then test imports in other modules. the below strategy is adequate:
# put the following in main.py
from tests.algorithms_tests import *
from tests.hash_tests import *
truck_test()
cli.cli_test()
algorithms_tests_test()
general_tests_test()
hash_test()
# put in truck.py
def truck_test():
    function_for_testing_imports('1')
# put in cli.py
def cli_test():
    function_for_testing_imports('2')
# put in tests/algorithms_tests
def algorithms_tests_test():
    function_for_testing_imports('3')
# put in tests/general_tests
def general_tests_test():
    function_for_testing_imports('4')
# put in package
def function_for_testing_imports(param):
    print(f"well hello there{param}")
# put in hash
def hash_test():
    hash_ex = Hash()
    print(f"called from hash_tests, here's a hash: {str(hash_ex)}")
