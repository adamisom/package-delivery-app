LEFT OFF: was gonna notate in doc which line numbers I refer to
in route_builder for Big(O)

REMAINING WORK:
Block 6: Code
	Subblock 13: ~50m / 9:40-10:30am / ACTUAL 10:00-11:06
		Make a deadlines list of location-time tuples in rb
		Pass that list + speed_fn to improve_route
		Make a new listcomp meets_deadlines before dist sums
			Keeps subroutes if TOTAL route UP THROUGH each 
			and every deadline is met
		Finally put min() in try/except with message that 
			deadlines can not all be met!
		In new fn meets_deadlines, cumulatively sum dist and 
			for each stop if it's in deadlines, return False
			if (use proj-arrival logic) it would be late,
			else continue / return True at end

	Subblock 14: ~30m / 10:30-11:00am / ACTUAL 11:15-12:02pm
		Get make_snapshot (and handle_) working again
		AND take all screenshots that I'll need for the paper

Block 7: Write
	Subblock 15: ~30m / 11:00-11:30am / ACTUAL 12:05-?
		Generate Big-O 'table' AND put screenshots in
	Subblock 16: ~30m / 11:30am-12:00 Noon
		Rejigger organization, rewrite parts of some sections
	Subblock 17: ~30m / 12:00-12:30pm
		Finish/flesh out anything else + finish clean-up

Block 8: Clean-Up / More-Code
	Subblock 18: ~30m / 12:45pm-1:15pm IN MY BEDROOM if not MLib
		Add hash + regex tests + Test my docstrings
	Subblock 19: ~50m / 1:15pm-2:05pm 
		Final clean-up of code/comments: ~15
		AND improve readme (add requirements and features): ~15
		AND add one or two general tests: ~15
		AND zip it or whatever and submit this + paper to WGU: ~5
----
How else I would improve the program
- optimize route could be enhanced to consider sets of segments that are shortest, which is another 'level' and thus should be another function. a clever way to manage O(n!) by splitting m up twice--could even extend again!
- adding nearby neighbors and adding stops at the end could revisit locations if it woudl save time. right now they both depend on find_nearest's implementation ignoring previously-visited packages. I know for a fact this would reduce the time I was getting from (93.9-chagne later) to (90.0-change later)
- a way to test different acceptable_increases and pick a good local minimum between 1.4 and 2.6 ish.

For later..
  If I need to/could describe 'destinations corrections' in my write-up...
"Destination corrections are received from the user of a program. This is necessary because currently neither corrected destinations nor the time by which a corrected destination will be known is part of the ‘package’ csv input file. Functionality in the cli module gathers all known destination-corrections and updates the relevant packages."
--------------------------------------
----from How to Design Programs / HtDP
TOP TIPS
	1. Keep a wish list around and as long as it's not empty, work from it
	2. One function per task
	3. Focus on the why, not how, especially in the purpose statement. Do not pay attention to how until you need to. (Especially for recursion.)
	4. For some list processing you may want to ensure
a list is non-empty before working with it.

WISH LIST
	1. meaningful name for the function
	2. signature (consume/produce)
	3. purpose statement

SHORT DESIGN RECIPE
	1. analyze problem
	2. write what kind of data is consumed and produced, what is computed, and write a stub/signature
	3. work through examples
	4. outline the function
	5. flesh out the function
	6. test

FUNCTION DESIGN RECIPE
	1. tentative function-name and multi-line comment
	2. sentence(s) on what it's supposed to, especially in terms of data
	3. data definitions/context--what kind of data, and what it represents
	4. parameters and return statement
	5. one-line purpose
	6. improve function name
	7. delete sentence(s) from step 2
	6. generate examples as given:/expect:
	7. convert simpler examples to test(s)
	8. develop the function
	9. pass those test(s)
	10. convert more examples into tests
	11. develop the function
	12. pass those tests
	13. move the tests into a testing file and rerun them there
	14. clean up the function
